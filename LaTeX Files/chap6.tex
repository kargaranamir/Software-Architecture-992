% Chapter 7 
\chapter{قابلیت آزمون}
\section{تعریف قابلیت آزمون}
طبق تخمین ها بین ۳۰ تا ۵۰ درصد هزینه تولید یک سیستم به آزمون سیستم اختصاص دارد.قابلیت آزمون\LTRfootnote{Testability} به سهولت ساخت نرم افزار برای نشان دادن عیب های خود از طریق آزمون اشاره دارد. به طور خاص ، قابلیت آزمون احتمال آن است که اگر برنامه دارای خطایی باشد،‌در آزمون خطا خود را نشان دهد. به صورت شهودی ، اگر یک سیستم به راحتی خطا های خود را آشکار سازد ،‌دارای قابلیت آزمون است

معیارهای پاسخ دهی برای قابلیت آزمون به میزان موثر بودن آزمون ها در کشف عیب ها و مدت زمان انجام آزمایش ها تا رسیدن به حد مطلوبی از پوشش\LTRfootnote{Coverage} مربوط می شوند.

\section{سناریوی عمومی قابلیت آزمون}
سناریو‌ی عمومی قابلیت استفاده به صورت زیر است:
\begin{itemize}
\item
منبع محرک\LTRfootnote{Source of stimulus} : هر کسی که برای سیستم آزمون طراحی می کند می تواند جز محرک های سناریو عمومی باشد.آزمون های طراحی شده می توانند به صورت دستی یا اتوماتیک اجرا شوند.
\item
محرک\LTRfootnote{Stimulus} : اجرای مجموعه ی خاصی از آزمون ها که می تواند به یکی از دلایل اضافه شدن مولفه ای جدید یا تحویل به مشریان صورت پذیرفته باشد.
\item
محصول\LTRfootnote{Artifact}: سیستم یا بخشی از آن که مورد آزمون قرار می گیرد.
\item
محیط\LTRfootnote{Enviroment}:: زمان طراحی ، زمان توسعه ، زمان کامپایل ، زمان ادغام\LTRfootnote{Integration Time} ، زمان استقرار\LTRfootnote{Deployment Time} ، زمان اجرا
\item
پاسخ\LTRfootnote{Response} : 
پاسخ سیستم می تواند زیر مجموعه ای از موارد زیر باشد.
\begin{itemize}
\item
اجرای مجموعه ی آزمون ها و دریافت پاسخ آن ها
\item
جمع آوری فعالیت هایی که به خطا در آزمون منجر شده اند
\item
کنترل و نظارت بر وضعیت سیستم
\end{itemize}

\item
اندازه گیری پاسخ\LTRfootnote{Response Measure}: یک یا چند مورد از این موارد را می‌توان به عنوان اندازه گیری استفاده نمود.
\begin{itemize}
\item
تلاش برای یافتن یک عیب یا کلاسی از عیب ها
\item
تلاش برای دستیابی به درصد معینی از پوشش فضا\LTRfootnote{Space Coverage}
\item
احتمال بروز خطا در آزمون بعدی
\item
زمان انجام آزمون ها
\item
طول طولانی ترین زنجیره وابستگی در آزمون
\item
مدت زمان آماده سازی محیط آزمون
\end{itemize}
\end{itemize}

\section{تاکتیک ها در قابلیت آزمون}
هدف تاکتیک های قابلیت آزمون آسان تر ساختن انجام آزمون ها پس از پایان فرآیند توسعه اولیه سیستم است.روش هایی که برای افزایش قابلیت آزمون وجود دارند در دو دسته از تاکتیک های قابلیت آزمون قرار می گیرند؛‌دسته ی اول به قابلیت کنترل و نظارت بر سیستم می افزایند و از این طریق انجام آزمون ها را آسان تر می سازند و دسته ی دیگر بر محدود کردن پیچیدگی های سیستم تمرکز می کنند.
\subsection{کنترل و نظارت بر وضعیت سیستم}
ساده ترین شکل کنترل و نظارت بر یک سیستم نرم افزاری با مجموعه ای از ورودی ها است.اجازه می دهید سیستم کار خود با ورودی های داده شده را انجام دهد و سپس خروجی آن را مشاهده می کنید.به صورت خاص روش هایی که در این دسته بندی وجود دارند شامل موارد زیر هستند:
\begin{itemize}
\item
رابط های تخصصی\LTRfootnote{Specialized interfaces} :
برخورداری از یک رابط این قابلیت را می دهد که در زمان آزمون نرم افزار یا اجرا عادی به مقادیر متغیر ها در برنامه دسترسی داشته باشیم. 
\item
ضبط/پخش \LTRfootnote{Record/Playback} :
بازایجاد حالتی که خطا در آن رخ می دهد در بسیاری از مواقع دشوار است.ضبط حالت هنگام فراخوانی یک رابط باعث می شود تا از این حالت برای ایجاد مجدد خطا استفاده شود.
\item
محلی سازی ذخیره سازی \LTRfootnote{Localize state storage} :
برای راه اندازی یک سیستم یا زیرسیستم از یک حالت آغازین تصادفی به منظور آزمون،‌بهترین روش این است که آن حالت در یک مکان واحد ذخیره شود.
\item
منابع داده انتزاعی \LTRfootnote{Abstract data sources} :
استفاده از منابع داده ای انتزاعی این امکان را به شما می دهد تا داده های آزمون را راحت تر جایگزین کنید.به عنوان مثال ، اگر پایگاه داده ای از داده های قابل آزمون را در اختیار داشته باشید ، می توانید معماری خود را طوری طراحی کنید که به راحتی در مواقع آزمون سیستم از پایگاه داده ی مخصوص آزمون استفاده کند.
\item
جعبه شنی \LTRfootnote{Sandbox} :
منظور از جعبه شنی این است که نمونه ای از سیستم را از دنیای واقعی جدا کنید تا بتوانید آزمونی را انجام دهید بدون آن که نگرانی ای در مورد عواقب آزمون شما را نگران کند.با استفاده از جعبه شنی می توانید نسخه ای از منابعی را که رفتار آن تحت کنترل شماست،‌بسازید.
\item
ادعاهای قابل اجرا \LTRfootnote{Executable assertions} :
با استفاده از این تاکتیک ،‌ادعاها معمولا به صورت دستی کد زده می شوند و در مکان های دلخواه قرار می گیرند تا نشان دهند چه زمانی و در کجا برنامه در وضعیت معیوبی قرار دارد.
\end{itemize}
\subsection{محدودسازی پیچیدگی های سیستم}
هر چقدر یک نرم افزار پیچیده تر باشد، آزمون آن سخت تر خواهد بود زیرا بنا بر تعریف پیچیدگی ، فضای حالت عملیاتی یک برنامه ی پیچیده بسیار بزرگ است و ایجاد مجدد یک حالت خاص در یک فضای حالت بزرگ دشوارتر از انجام این کار در فضای حالت کوچک است.به طور خاص دو روش زیر به محدودسازی پیچیدگی نرم افزار کمک می کنند.
\begin{itemize}
\item
محدود‌سازی پیچیدگی ساختاری :
این تاکتیک شامل اجتناب یا حل وابستگی های حلقوی میان مولفه های سیستم ، جداسازی و کپسول سازی\LTRfootnote{Encapsulation} وابستگی ها به محیط خارجی و کاهش وابستگی بین اجزا به طور کلی است.در این روش می توانید عمق درخت ارث بری \LTRfootnote{Inheritence} و تعداد فرزندان یک کلاس را محدود کنید.
\item
دوری از عدم قطعیت \LTRfootnote{Nondeterminism} :
این تاکتیک شامل یافتن تمام منابع عدم قطعیت، مانند موازی کاری غیرقانونی و حذف هرچه بیشتر آنها است.
\end{itemize}
\section{طراحی فهرست بازبینی برای قابلیت آزمون}
\subsection{تخصیص مسئولیت ها} 
در مورد تخصیص مسئولیت ها موارد زیر باید بررسی شوند:
\begin{itemize}
\item
تعیین کنید مهم ترین مسئولیت های سیستم چه مسئولیت هایی هستند زیرا این مسئولیت ها باید به دقت مورد آزمون قرار گیرند.
\item
اطمینان حاصل کنید مولفه هایی در سیستم وظایف زیر را بر عهده دارند.
\begin{itemize}
\item
اجرای تست ها و دریافت نتایج حاصل از آن ها
\item
ذخیره سازی لاگ\LTRfootnote{Logs} ها رفتار های غیر قابل پیش‌بینی سیستم و لاگ خطا های رخ داده در سیستم
\item
کنترل و نظارت بر حالت های مرتبط با سیستم به جهت آزمون سیستم
\end{itemize}
\item
اطمینان حاصل کنید که تخصیص عملکرد ها انسجام بالا ، اتصال\LTRfootnote{coupling} کم ، جدایی شدید نگرانی ها\LTRfootnote{separation of concerns} و پیچیدگی ساختاری کم را فراهم می کند.
\end{itemize}

\subsection{مدل هماهنگی}
از مکانیسم های هماهنگی و ارتباط سیستم اطمینان حاصل کنید:
\begin{itemize}
\item
پشتیبانی از اجرای تست ها و دریافت پاسخ آن ها در یک یا میان چندین سیستم
\item
پشتیبانی از دریافت تاریخچه خطا های رخ داد در یک سیستم و یا میان چندین سیستم
\item
پشتیبانی از تزریق\LTRfootnote{Injection} و نظارت\LTRfootnote{Monitoring} بر وضعیت در کانال های ارتباطی برای استفاده در آزمون ها،‌درون یک سیستم یا بین سیستم ها
\end{itemize}
\subsection{مدل داده}
در بخش باید انتزاعات اصلی داده را که باید برای اطمینان از عملکرد صحیح سیستم مورد آزمون قرار گیرند را تعیین کنید.
\begin{itemize}
\item
اطمینان حاصل کنید که امکان گرفتن مقادیر نمونه های این انتزاعات داده وجود دارد.
\item
اطمینان حاصل کنید که می توان مقادیر نمونه های این انتزاعات داده را هنگام تزریق حالت به سیستم تنظیم کرد؛‌بنابرین می توانیم حالت سیستم که منجر به خطا شده است،‌دوباره قابل ایجاد است.
\item
اطمینان حاصل کنید که هر گونه تغییر در این داده های انتزاعی ممکن و قابل آزمون است.
\end{itemize}
\subsection{نقشه برداری در میان عناصر معماری}
نحوه آزمون نگاشت های احتمالی عناصر معماری (به ویژه نگاشت فرآیندها به پردازنده ها ،‌رشته ها برای پردازش ها و ماژول ها به اجزا) را تعیین کنید تا پاسخ آزمون مورد نظر حاصل شود و وجود وضعیت رقابتی\LTRfootnote{Race Condition} مشخص شود.
\subsection{مدیریت منابع}
در این بخش باید از وجود منابع کافی جهت اجرای آزمون های اطمینان حاصل کنید و همچنین مطمئن شوید محیطی که آزمون ها در آن به اجر در می آیند نمود محیط واقعی که سیستم در آن فعالیت می کند است.

در بحث مدیریت منابع باید به موارد زیر توجه شود:

\begin{itemize}
\item
محدودیت منابع آزمون
\item
ثبت دقیق مصرف منابع در هنگام رویداد ها علی الخصوص خطا ها
\item
وضع محدودیت های جدید بر روی منابع برای آزمون شرایط خاص
\item
ایجاد منابع مجازی با هدف آزمون
\end{itemize}
\subsection{زمان اتصال}
در این بخش باید اطمینان حاصل کنید مولفه هایی که پس از زمان کامپایل دیرهنگام به سیستم متصل می‌شوند از قابلیت آزمون برخوردار هستند.
\subsection{انتخاب فناوری}
انتخاب فناوری باید به گونه‌ای باشد که سناریو‌های قابلیت آزمون را بر روی سیستم بتوان اجرا کرد.